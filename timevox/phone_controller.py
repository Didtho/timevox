# phone_controller.py
"""
Contr√¥leur principal du t√©l√©phone TimeVox
Version avec dur√©e d'enregistrement, volume audio et longueur du num√©ro principal configurables
Version avec menu param√®tres √©tendu et gestion des mises √† jour
"""

import time
from gpio_manager import GPIOManager
from usb_manager import USBManager
from audio_manager import AudioManager
from recording_manager import RecordingManager
from display_manager import DisplayManager
from dialer_manager import DialerManager
from rtc_manager import RTCManager 
from config import TARGET_NUMBERS, SERVICE_NUMBERS
import subprocess
from datetime import datetime
from params_menu_manager import ParamsMenuManager  # Nouveau nom
from update_manager import UpdateManager


class PhoneController:
    def __init__(self):
        print("Initialisation TimeVox...")
        
        # Initialisation du gestionnaire RTC en premier
        print("Initialisation du gestionnaire RTC...")
        self.rtc_manager = RTCManager()
        
        # V√©rification de l'heure au d√©marrage
        status_info = self.rtc_manager.get_status_info()
        print(f"√âtat RTC: Disponible={status_info['rtc_available']}, "
              f"Heure valide={status_info['time_valid']}")
        
        if not status_info['time_valid']:
            print("ATTENTION: L'heure syst√®me semble incorrecte!")
            print("Tentative de synchronisation r√©seau...")
            self.rtc_manager.sync_time_if_network_available()
        
        # Initialisation des gestionnaires de base
        self.gpio_manager = GPIOManager()
        self.display_manager = DisplayManager()
        
        # Passer le RTC au USBManager
        self.usb_manager = USBManager(self.rtc_manager)
        
        # Afficher le message d'initialisation
        self.display_manager.show_initialization()

        # Configuration du bouton d'arr√™t
        self.shutdown_button_gpio = 26
        self.shutdown_led_gpio = 16
        self.shutdown_button_pressed_time = None
        self.shutdown_in_progress = False
        
        # Configurer les GPIO du bouton d'arr√™t
        self.setup_shutdown_button()

        # Initialiser AudioManager avec usb_manager pour la gestion du volume
        self.audio_manager = AudioManager(self.gpio_manager, self.usb_manager)
        
        # Initialiser RecordingManager avec usb_manager
        self.recording_manager = RecordingManager(
            self.gpio_manager, 
            self.audio_manager, 
            self.display_manager,
            self.usb_manager  # Passer le gestionnaire USB
        )
        
        # IMPORTANT: Initialiser le DialerManager AVANT ParamsMenuManager
        self.dialer_manager = DialerManager(
            self.gpio_manager, 
            self.display_manager,
            self.usb_manager  # Passer le gestionnaire USB au lieu de la liste
        )
        
        # MAINTENANT initialiser ParamsMenuManager (nouveau nom) apr√®s que dialer_manager existe
        self.params_menu_manager = ParamsMenuManager(
            self.display_manager,
            self.dialer_manager,
            self.usb_manager,
            self.audio_manager,
            self.gpio_manager
        )
        
        # Initialiser le gestionnaire de mises √† jour
        self.update_manager = UpdateManager(self.usb_manager)
        
        # Affichage des informations de configuration
        config_info = self.usb_manager.get_config_info()
        print(f"=== CONFIGURATION TIMETVOX ===")
        print(f"Num√©ro principal: {config_info['numero_principal']} ({config_info['longueur_numero_principal']} chiffres)")
        print(f"Num√©ros de service: {list(SERVICE_NUMBERS.keys())}")  # Maintenant juste ["0000"]
        print(f"Dur√©e d'enregistrement: {config_info['duree_enregistrement']}s")
        print(f"Volume audio: {config_info['volume_audio']}%")

        # Affichage des param√®tres de filtre
        try:
            from audio_effects import AudioEffects
            audio_effects = AudioEffects(self.usb_manager)
            filter_config = audio_effects.get_filter_config()
            print(f"Filtre vintage: {'‚úÖ Activ√©' if filter_config['enabled'] else '‚ùå D√©sactiv√©'}")
            if filter_config['enabled']:
                print(f"  - Type: {filter_config['type']}")
                print(f"  - Intensit√©: {filter_config['intensity']}")
                print(f"  - Conserver original: {'Oui' if filter_config['keep_original'] else 'Non'}")
        except:
            print(f"Filtre vintage: ‚ùì Non configur√©")

        # Affichage version actuelle
        try:
            current_version = self.update_manager.get_current_version()
            print(f"Version TimeVox: {current_version}")
        except:
            print(f"Version TimeVox: Inconnue")

        print(f"Cl√© USB: {'‚úÖ D√©tect√©e' if config_info['usb_available'] else '‚ùå Non d√©tect√©e'}")
        print(f"RTC: {'‚úÖ Op√©rationnel' if config_info.get('rtc_available', False) else '‚ùå Non disponible'}")
        print(f"Heure: {config_info.get('current_time', 'N/A')}")
        print(f"===============================")
        
        print("Initialisation termin√©e. Attente stabilisation...")
        time.sleep(5)
        
        # V√©rifier les mises √† jour au d√©marrage
        self.check_updates_at_startup()
        
        # Effacer le message d'initialisation
        self.display_manager.clear_display()
        
        print("Pr√™t √† d√©tecter un num√©ro fait au cadran.")
    
    def check_updates_at_startup(self):
        """V√©rifie s'il y a une mise √† jour disponible au d√©marrage"""
        try:
            print("üîÑ V√©rification des mises √† jour au d√©marrage...")
            if self.update_manager.check_update_at_startup():
                print("üì¢ Mise √† jour disponible - affichage sur OLED")
                from oled_display import afficher
                afficher("", "MAJ disponible", "", taille=14, align="centre")
                time.sleep(3)
            else:
                print("‚úÖ Aucune mise √† jour disponible")
        except Exception as e:
            print(f"Erreur v√©rification MAJ au d√©marrage: {e}")
    
    def handle_numero_principal(self):
        """Traite l'appel au num√©ro principal (annonce + enregistrement)"""
        print("üéµ Activation du son...")
        self.gpio_manager.enable_sound()
        time.sleep(0.5)  # Laisser le temps au son de s'activer

        # Lecture du fichier de recherche de correspondant
        search_path = self.audio_manager.get_search_correspondant_path()
        if search_path:
            print("üì¢ Fichier search_correspondant trouv√©, lecture en cours...")
            if not self.audio_manager.play_audio(search_path):
                print("‚ùå √âchec lecture search_correspondant")
                self.gpio_manager.disable_sound()
                return

        # Lecture de l'annonce principale
        announce_path = self.usb_manager.get_announce_path()
        print(f"DEBUG: announce_path retourn√© = {announce_path}")
        if announce_path:
            print(f"üì¢ Lecture annonce principale: {announce_path}")
            if not self.audio_manager.play_audio(announce_path):
                print("‚ùå √âchec lecture annonce principale")
                self.gpio_manager.disable_sound()
                return
        else:
            print("‚ùå Annonce non disponible - cl√© USB non d√©tect√©e")
            self.gpio_manager.disable_sound()
            return

        print("üîá Coupure du son...")
        self.gpio_manager.disable_sound()

        # V√©rification que le t√©l√©phone est toujours d√©croch√©
        if self.gpio_manager.is_phone_off_hook():
            # G√©n√©ration du nom de fichier d'enregistrement
            nom_fichier = self.usb_manager.generate_message_filename()
            if nom_fichier:
                # Utiliser la dur√©e configur√©e depuis la cl√© USB
                duree_config = self.usb_manager.get_duree_enregistrement()
                print(f"üéôÔ∏è D√©but enregistrement: {nom_fichier} (dur√©e: {duree_config}s)")
                self.recording_manager.record_message(
                    duration=duree_config, 
                    output_file=nom_fichier
                )
            else:
                print("‚ùå Impossible d'enregistrer - cl√© USB non disponible")
        else:
            print("üìû T√©l√©phone raccroch√© - pas d'enregistrement")
    
    def handle_number_0000(self):
        """Traite l'appel au num√©ro 0000 (acc√®s param√®tres)"""
        self.gpio_manager.disable_sound()
        print("üîß Acc√®s param√®tres (0000)")
        
        # Nouveau menu de param√®tres unifi√©
        self.params_menu_manager.start_params_menu()
    
    def handle_phone_hangup(self):
        """Traite le raccrochage du t√©l√©phone"""
        # Arr√™t de la composition
        if self.dialer_manager.is_composing():
            print("üìû Raccrochage pendant composition - reset")
            self.dialer_manager.reset_dialing(clear_display=True)

        # Arr√™t de l'enregistrement
        if self.recording_manager.recording_active:
            if self.recording_manager.recording_started:
                print("üéôÔ∏è Raccrochage pendant enregistrement")
                self.display_manager.show_saving()
                self.recording_manager.stop_recording()
            else:
                print("üìû Raccrochage avant d√©but enregistrement")
                self.recording_manager.recording_active = False

        # Arr√™t de la musique si en cours
        self.audio_manager.stop_audio()
        self.gpio_manager.disable_sound()
        
        # Effacer l'√©cran
        self.display_manager.clear_display()
        
    def setup_shutdown_button(self):
        """Configure le bouton d'arr√™t et la LED power"""
        # Utiliser le GPIO manager existant
        self.gpio_manager.setup_input_pin(self.shutdown_button_gpio)
        self.gpio_manager.setup_output_pin(self.shutdown_led_gpio)
        self.gpio_manager.gpio_write(self.shutdown_led_gpio, True)  # LED power allum√©e
        print(f"üîò Bouton d'arr√™t configur√© sur GPIO {self.shutdown_button_gpio}")
        print(f"üí° LED power allum√©e sur GPIO {self.shutdown_led_gpio}")
        
    def check_shutdown_button(self):
        """V√©rifie l'√©tat du bouton d'arr√™t"""
        if self.shutdown_in_progress:
            return
            
        button_pressed = not self.gpio_manager.gpio_read(self.shutdown_button_gpio)
        
        if button_pressed:
            if self.shutdown_button_pressed_time is None:
                # D√©but de l'appui
                self.shutdown_button_pressed_time = time.time()
                self.display_manager.show_shutdown_message("Arret en cours...")
                print("üîò Bouton d'arr√™t press√© - d√©compte d√©marr√©")
                
            # V√©rifier dur√©e d'appui
            press_duration = time.time() - self.shutdown_button_pressed_time
            
            # Faire clignoter la LED pendant l'appui
            if int(press_duration * 4) % 2 == 0:  # 2 Hz
                self.gpio_manager.gpio_write(self.shutdown_led_gpio, True)
            else:
                self.gpio_manager.gpio_write(self.shutdown_led_gpio, False)
                
            # Arr√™t apr√®s 3 secondes
            if press_duration >= 3:
                self.initiate_shutdown()
                
        else:
            if self.shutdown_button_pressed_time is not None:
                # Bouton rel√¢ch√© avant 3 secondes
                self.shutdown_button_pressed_time = None
                self.gpio_manager.gpio_write(self.shutdown_led_gpio, True)  # LED fixe
                self.display_manager.clear_display()
                print("üîò Bouton d'arr√™t rel√¢ch√© - annulation")

    def initiate_shutdown(self):
        """Lance la proc√©dure d'arr√™t"""
        if self.shutdown_in_progress:
            return
            
        self.shutdown_in_progress = True
        print("=== ARR√äT SYST√àME DEMAND√â ===")
        
        # Messages successifs sur l'√©cran
        self.display_manager.show_shutdown_message("Fermeture...")
        time.sleep(1)
        
        self.display_manager.show_shutdown_message("Sauvegarde...")
        time.sleep(1)
        
        self.display_manager.show_shutdown_message("Au revoir!")
        time.sleep(1)
        
        # √âteindre la LED juste avant l'arr√™t
        self.gpio_manager.gpio_write(self.shutdown_led_gpio, False)
        
        # Nettoyer et arr√™ter
        self.cleanup()
        
        # Arr√™t syst√®me
        subprocess.run(["sudo", "shutdown", "-h", "now"])
    
    def run(self):
        """Boucle principale du contr√¥leur"""
        try:
            while True:
                # V√©rifier le bouton d'arr√™t EN PREMIER
                self.check_shutdown_button()
                
                # Si arr√™t en cours, sortir de la boucle
                if self.shutdown_in_progress:
                    break
                
                phone_off_hook = self.gpio_manager.is_phone_off_hook()
                
                if not phone_off_hook:
                    # T√©l√©phone raccroch√©
                    self.handle_phone_hangup()
                else:
                    # T√©l√©phone d√©croch√©
                    if (not self.dialer_manager.is_composing() and 
                        not self.recording_manager.recording_active):
                        # Afficher TIMEVOX si aucune activit√©
                        self.display_manager.show_timevox()
                    
                    # Traitement du cadran avec la nouvelle logique
                    completed_number = self.dialer_manager.process_dialing()
                    if completed_number:
                        # Maintenir l'affichage du num√©ro pendant le traitement
                        self.display_manager.show_calling_number(completed_number)
                        
                        # Traitement selon le type de num√©ro reconnu
                        numero_principal = self.usb_manager.get_numero_principal()
                        
                        if completed_number == numero_principal:
                            print(f"üìû Appel num√©ro principal: {completed_number}")
                            self.handle_numero_principal()
                        elif completed_number == "0000":
                            print(f"üîß Appel param√®tres: {completed_number}")
                            self.handle_number_0000()
                        else:
                            print(f"‚ùì Num√©ro non g√©r√©: {completed_number}")
                        
                        # Effacer seulement apr√®s traitement complet
                        self.display_manager.clear_display()

                time.sleep(0.005)  # Petite pause pour √©viter la surcharge CPU
                
        except KeyboardInterrupt:
            print("\n‚õî Arr√™t demand√© par l'utilisateur")
        finally:
            self.cleanup()
    
    def cleanup(self):
        """Nettoyage des ressources"""
        print("üßπ Nettoyage des ressources...")
        
        # √âteindre la LED power
        try:
            self.gpio_manager.gpio_write(self.shutdown_led_gpio, False)
        except:
            pass
            
        # Effacer l'√©cran
        self.display_manager.clear_display()
        
        # Nettoyage GPIO original
        self.gpio_manager.cleanup()
        
        print("üëã TimeVox arr√™t√©.")